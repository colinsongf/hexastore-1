TODO:

[optimizer]

Implement query plan optimizer (based on which indexes are available, pushing down projection/filters). Start with a dynamic programming optimizer, then extend to IDP-balanced-bestRow (IDP1 will give monotonicity, but is slower than IDP2).

** the computation for interesting plans needs to take into account possible mergejoins later on in the query plan.

** the existing optimizer code needs to be fixed to not use hx_index directly (which isn't a public API following the refactoring of the backend triplestore code).


[storage]

Add a persistent, tokyocabinet-based backend store.

[sortedby]

Revamp the sorted_by code for variablebindings iterators. Right now there's the hx_variablebindings_iter_is_sorted_by_index function, but this needs to be extended to returning an array of expressions (with flag for ascending/descending), so we can tell that a variablebindings iterator is sorted by, e.g., "ASC(?s), DESC(STR(?p))".

[api-changes]

hx_optimizer_join_plans should do garbage collection on the passed in container objects instead of making the calling code do it (the common case is probably that they're passed to hx_optimizer_join_plans and never used again, so let's make the uncommon case (as the code is now) require an explicit copy of the plan containers).



Notes:

[2009.08.21]

5M triples can be loaded in 4GB of RAM, tested on CCNI opterons. Look to load <1MT/GB of memory (maybe closer to 1/2 = 625kT/GB) to leave room for intermediate results.
