TODO:

[raptor parser]

- Fix bnode id assignment code to give unique IDs, and to keep the assignments around so that they are used the next time the bnode is referenced. This code (parser/parser.c:_hx_parser_generate_id) is commented out for now, and we're just relying on raptor's own ID assignment which can give duplicate IDs if you use the parser twice in a row. _hx_parser_generate_id currently can generate unique IDs, but isn't keeping them around, so two references to a single bnode in an RDF file will result in two IDs being generated.


[optimizer]

Implement query plan optimizer (based on which indexes are available, pushing down projection/filters). Start with a dynamic programming optimizer, then extend to IDP-balanced-bestRow (IDP1 will give monotonicity, but is slower than IDP2).

optimizer/optimizer.c:hx_optimizer_optimize_bgp currently implements the dynamic programming algorithm for BGPs. It needs to be generalized and split up to handle a BGP-like structure comprised of several access plans, not triple patterns. This will allow the algorithm to be extended to the IDP algorithm, where several triple pattern access plans in the first optimizer pass are replaced with a single join plan in successive passes (we might call the first pass with access plans T1,T2,T3, and the second pass with J1,T2 with J1 standing in for the best found plan for T1,T3).

** the computation for interesting plans needs to take into account possible mergejoins later on in the query plan.

** the existing optimizer code needs to be fixed to not use hx_index directly (which isn't a public API following the refactoring of the backend triplestore code).

Update the optimizer code to determine when variables are only referenced once, and rewrite the triple pattern to use (hx_node_id) 0 instead of an actual variable ID (hx_node_id with a negative value). This can be conditionally turned on when running under DISTINCT or REDUCED, and allow the storage implementations to only return zero or one results per variable of this kind. For example, we might want all people with foaf:name properties, but not care what the actual names are: {?p foaf:name _:a}. As long as _:a isn't referenced anywhere else in the query, performance can be improved by letting the storage backend only return a single result (with only ?p bound) for each person, even if they have many foaf:name properties.


[storage]

Finish the tokyocabinet-based backend store (including more unit tests to make sure iterators and removing of triples is working).

- Add a bulk-loading API that loads new triples into indexes sequentially, one at a time (followed by updating the aggregate counts index). This should help with btree nodes being cachable (keeping 1-2 tree's nodes cached instead of 6-7).
- Once this is working, extend the implementation to support quads.

Implement hx_store_triple_orderings, letting store implementations return thunks that refer to their available internal indexes. The optimizer can then use these to construct access plans. Along with this change, we'll need a new variablebindings iterator constructor (and possible also a count function for the optimizer to use in cost estimation) that can take one of these thunks as an argument so that the optimizer can force use of what it thinks is the best index. The thunks could just be strings (e.g. "SOP"), but maybe they should be more complicated to allow custom indexes (like an index on just statements involving xsd:integers or XMLLiterals). In any case, the actual thunk should be opaque to calling code.

Update the hx_store_get_statements implementations to work even if an appropriate index isn't present. For example, if the SOP index is decided upon as the appropriate index, but only SPO, PSO, and OPS are available, the code should be able to fall back on one of the existing indexes (depending on the constraints of what terms are bound and what the requested ordering is) to produce results. This will require often end up looking like a "table scan" over the entire index, with code to check that the bound triple pattern terms match (this can be thought of as a low-level implementation of an all-variable triple pattern with FILTERs to check the result values).

[sortedby]

Revamp the sorted_by code for variablebindings iterators. Right now there's the hx_variablebindings_iter_is_sorted_by_index function, but this needs to be extended to returning an array of expressions (with flag for ascending/descending), so we can tell that a variablebindings iterator is sorted by, e.g., "ASC(?s), DESC(STR(?p))". This will be set by the store implementations for hx_store_get_statements, and all the vb iter implementations (join, project, etc.) should propogate these ordering structs up to the top level.



Notes:

[2009.08.21]

5M triples can be loaded in 4GB of RAM, tested on CCNI opterons. Look to load <1MT/GB of memory (maybe closer to 1/2 = 625kT/GB) to leave room for intermediate results.
